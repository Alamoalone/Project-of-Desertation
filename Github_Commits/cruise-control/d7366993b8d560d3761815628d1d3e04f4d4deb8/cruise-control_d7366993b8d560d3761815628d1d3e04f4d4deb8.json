{
    "sha": "d7366993b8d560d3761815628d1d3e04f4d4deb8",
    "node_id": "C_kwDOBfwEs9oAKGQ3MzY2OTkzYjhkNTYwZDM3NjE4MTU2MjhkMWQzZTA0ZjRkNGRlYjg",
    "commit": {
        "author": {
            "name": "Sandeep Boddu",
            "email": "boddusandeep23@gmail.com",
            "date": "2023-12-13T21:17:53Z"
        },
        "committer": {
            "name": "GitHub",
            "email": "noreply@github.com",
            "date": "2023-12-13T21:17:53Z"
        },
        "message": "Handle null pointer exception on partition info when making is partition under replicated check (#2083)",
        "tree": {
            "sha": "cccead05b660bcec681549105b374cfa9d028db1",
            "url": "https://api.github.com/repos/linkedin/cruise-control/git/trees/cccead05b660bcec681549105b374cfa9d028db1"
        },
        "url": "https://api.github.com/repos/linkedin/cruise-control/git/commits/d7366993b8d560d3761815628d1d3e04f4d4deb8",
        "comment_count": 0,
        "verification": {
            "verified": true,
            "reason": "valid",
            "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJleh+BCRBK7hj4Ov3rIwAAG+8IAGm6cqYkD3LF92SfUBewloIU\nRkN48UijFXUjT9EWjLCPgFnowvb8CxbyRJPTsntGgk8O75mTF+z2rRIO5kKZxrkq\nDT8XRv0Gj7GcSkEFr15kyaS7S/vJL39pXJfFH4YsXAEc5K8hzZpJcn2SSw2W+4fm\nTaDMILthIQ3z+qc79YkploWozzeo3HXe3wo2chHSN7immpKain0plPqESKhIordU\naZnZpWrG4MKK2rBQIf2fsFgYxhaFRgXADCW6YB1Z6DthEFEsrxksEYP6ycClMZY8\narQDKsqtYiyUJ+kH7Vyo6/kdttT5hDfbVr+7g0hXHHRFxHNSZ8MML//6gFBrfRs=\n=Rpda\n-----END PGP SIGNATURE-----\n",
            "payload": "tree cccead05b660bcec681549105b374cfa9d028db1\nparent f4ca900e58944478b539955a3d70fcd802c0e1a8\nauthor Sandeep Boddu <boddusandeep23@gmail.com> 1702502273 +0530\ncommitter GitHub <noreply@github.com> 1702502273 -0800\n\nHandle null pointer exception on partition info when making is partition under replicated check (#2083)\n\n"
        }
    },
    "url": "https://api.github.com/repos/linkedin/cruise-control/commits/d7366993b8d560d3761815628d1d3e04f4d4deb8",
    "html_url": "https://github.com/linkedin/cruise-control/commit/d7366993b8d560d3761815628d1d3e04f4d4deb8",
    "comments_url": "https://api.github.com/repos/linkedin/cruise-control/commits/d7366993b8d560d3761815628d1d3e04f4d4deb8/comments",
    "author": {
        "login": "bsandeep23",
        "id": 15901412,
        "node_id": "MDQ6VXNlcjE1OTAxNDEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/15901412?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bsandeep23",
        "html_url": "https://github.com/bsandeep23",
        "followers_url": "https://api.github.com/users/bsandeep23/followers",
        "following_url": "https://api.github.com/users/bsandeep23/following{/other_user}",
        "gists_url": "https://api.github.com/users/bsandeep23/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bsandeep23/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bsandeep23/subscriptions",
        "organizations_url": "https://api.github.com/users/bsandeep23/orgs",
        "repos_url": "https://api.github.com/users/bsandeep23/repos",
        "events_url": "https://api.github.com/users/bsandeep23/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bsandeep23/received_events",
        "type": "User",
        "site_admin": false
    },
    "committer": {
        "login": "web-flow",
        "id": 19864447,
        "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/web-flow",
        "html_url": "https://github.com/web-flow",
        "followers_url": "https://api.github.com/users/web-flow/followers",
        "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
        "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
        "organizations_url": "https://api.github.com/users/web-flow/orgs",
        "repos_url": "https://api.github.com/users/web-flow/repos",
        "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
        "received_events_url": "https://api.github.com/users/web-flow/received_events",
        "type": "User",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "f4ca900e58944478b539955a3d70fcd802c0e1a8",
            "url": "https://api.github.com/repos/linkedin/cruise-control/commits/f4ca900e58944478b539955a3d70fcd802c0e1a8",
            "html_url": "https://github.com/linkedin/cruise-control/commit/f4ca900e58944478b539955a3d70fcd802c0e1a8"
        }
    ],
    "stats": {
        "total": 328,
        "additions": 318,
        "deletions": 10
    },
    "files": [
        {
            "sha": "50d6f5397237b93e124568df8227ad41143e8506",
            "filename": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControlUtils.java",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/linkedin/cruise-control/blob/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2FKafkaCruiseControlUtils.java",
            "raw_url": "https://github.com/linkedin/cruise-control/raw/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2FKafkaCruiseControlUtils.java",
            "contents_url": "https://api.github.com/repos/linkedin/cruise-control/contents/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2FKafkaCruiseControlUtils.java?ref=d7366993b8d560d3761815628d1d3e04f4d4deb8",
            "patch": "@@ -11,6 +11,7 @@\n import com.linkedin.kafka.cruisecontrol.config.constants.AnalyzerConfig;\n import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n import com.linkedin.kafka.cruisecontrol.config.constants.WebServerConfig;\n+import com.linkedin.kafka.cruisecontrol.exception.PartitionNotExistsException;\n import com.linkedin.kafka.cruisecontrol.exception.SamplingException;\n import com.linkedin.kafka.cruisecontrol.metricsreporter.CruiseControlMetricsUtils;\n import com.linkedin.kafka.cruisecontrol.metricsreporter.config.EnvConfigProvider;\n@@ -781,8 +782,12 @@ private static void setClassConfigIfExists(KafkaCruiseControlConfig configs, Map\n    * @param tp The topic partition to check.\n    * @return {@code true} if the partition is currently under replicated.\n    */\n-  public static boolean isPartitionUnderReplicated(Cluster cluster, TopicPartition tp) {\n+  public static boolean isPartitionUnderReplicated(Cluster cluster, TopicPartition tp) throws\n+                                                                                       PartitionNotExistsException {\n     PartitionInfo partitionInfo = cluster.partition(tp);\n+    if (partitionInfo == null) {\n+      throw new PartitionNotExistsException(\"Partition \" + tp + \" does not exist.\");\n+    }\n     return partitionInfo.inSyncReplicas().length != partitionInfo.replicas().length;\n   }\n "
        },
        {
            "sha": "751dfa4d1cb88ab4b1f5a009c1586fa5bcbf04f4",
            "filename": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/analyzer/goals/PreferredLeaderElectionGoal.java",
            "status": "modified",
            "additions": 20,
            "deletions": 4,
            "changes": 24,
            "blob_url": "https://github.com/linkedin/cruise-control/blob/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fanalyzer%2Fgoals%2FPreferredLeaderElectionGoal.java",
            "raw_url": "https://github.com/linkedin/cruise-control/raw/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fanalyzer%2Fgoals%2FPreferredLeaderElectionGoal.java",
            "contents_url": "https://api.github.com/repos/linkedin/cruise-control/contents/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fanalyzer%2Fgoals%2FPreferredLeaderElectionGoal.java?ref=d7366993b8d560d3761815628d1d3e04f4d4deb8",
            "patch": "@@ -9,6 +9,7 @@\n import com.linkedin.kafka.cruisecontrol.analyzer.BalancingAction;\n import com.linkedin.kafka.cruisecontrol.analyzer.ProvisionResponse;\n import com.linkedin.kafka.cruisecontrol.analyzer.ProvisionStatus;\n+import com.linkedin.kafka.cruisecontrol.exception.PartitionNotExistsException;\n import com.linkedin.kafka.cruisecontrol.model.Broker;\n import com.linkedin.kafka.cruisecontrol.model.ClusterModel;\n import com.linkedin.kafka.cruisecontrol.model.ClusterModelStats;\n@@ -62,11 +63,26 @@ private void sanityCheckOptimizationOptions(OptimizationOptions optimizationOpti\n     }\n   }\n \n+  private boolean shouldSkipOperationOnURP(TopicPartition tp, String operation) {\n+    // Return true if the partition is under replicated and the flag to skip URP demotion is set.\n+    // Return false otherwise.\n+    // If the partition doesn't exist, return true.\n+    // Operation string is solely for logging purpose in case of partition not found.\n+    try {\n+      return _skipUrpDemotion && isPartitionUnderReplicated(_kafkaCluster, tp);\n+    } catch (PartitionNotExistsException ex) {\n+      LOG.warn(\"Skip {} operation for partition {} due to exception: {}\", operation, tp, ex);\n+      return true;\n+    }\n+  }\n+\n   private void maybeMoveReplicaToEndOfReplicaList(Replica replica, ClusterModel clusterModel) {\n-    // There are two scenarios where replica swap operation is skipped:\n+    // There are three scenarios where replica swap operation is skipped:\n     // 1.the replica is not leader replica and _excludeFollowerDemotion is true.\n     // 2.the replica's partition is currently under replicated and _skipUrpDemotion is true.\n-    if (!(_skipUrpDemotion && isPartitionUnderReplicated(_kafkaCluster, replica.topicPartition()))\n+    // 3.the replica doesn't exist.\n+    boolean skipReplicaMove = shouldSkipOperationOnURP(replica.topicPartition(), \"replica move\");\n+    if (!skipReplicaMove\n         && !(_excludeFollowerDemotion && !replica.isLeader())) {\n       Partition p = clusterModel.partition(replica.topicPartition());\n       p.moveReplicaToEnd(replica);\n@@ -75,9 +91,9 @@ private void maybeMoveReplicaToEndOfReplicaList(Replica replica, ClusterModel cl\n \n   private void maybeChangeLeadershipForPartition(Set<Replica> leaderReplicas, Set<TopicPartition> partitionsToMove) {\n     // If the leader replica's partition is currently under replicated and _skipUrpDemotion is true, skip leadership\n-    // change operation.\n+    // change operation. If the partition is not found skip the operation as well.\n     leaderReplicas.stream()\n-                  .filter(r -> !(_skipUrpDemotion && isPartitionUnderReplicated(_kafkaCluster, r.topicPartition())))\n+                  .filter(r -> !shouldSkipOperationOnURP(r.topicPartition(), \"leadership change\"))\n                   .forEach(r -> partitionsToMove.add(r.topicPartition()));\n   }\n "
        },
        {
            "sha": "3d4f7e3b5df382af5433042c6d9aeb329b91246c",
            "filename": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/exception/PartitionNotExistsException.java",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/linkedin/cruise-control/blob/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fexception%2FPartitionNotExistsException.java",
            "raw_url": "https://github.com/linkedin/cruise-control/raw/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fexception%2FPartitionNotExistsException.java",
            "contents_url": "https://api.github.com/repos/linkedin/cruise-control/contents/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fexception%2FPartitionNotExistsException.java?ref=d7366993b8d560d3761815628d1d3e04f4d4deb8",
            "patch": "@@ -0,0 +1,14 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.exception;\n+\n+/**\n+ * An exception thrown when a partition does not exist.\n+ */\n+public class PartitionNotExistsException extends KafkaCruiseControlException {\n+    public PartitionNotExistsException(String message) {\n+      super(message);\n+    }\n+}"
        },
        {
            "sha": "b916001ac070084bd08dba9ca0760ea82d2aed27",
            "filename": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/strategy/PostponeUrpReplicaMovementStrategy.java",
            "status": "modified",
            "additions": 39,
            "deletions": 5,
            "changes": 44,
            "blob_url": "https://github.com/linkedin/cruise-control/blob/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fexecutor%2Fstrategy%2FPostponeUrpReplicaMovementStrategy.java",
            "raw_url": "https://github.com/linkedin/cruise-control/raw/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fexecutor%2Fstrategy%2FPostponeUrpReplicaMovementStrategy.java",
            "contents_url": "https://api.github.com/repos/linkedin/cruise-control/contents/cruise-control%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fexecutor%2Fstrategy%2FPostponeUrpReplicaMovementStrategy.java?ref=d7366993b8d560d3761815628d1d3e04f4d4deb8",
            "patch": "@@ -4,9 +4,12 @@\n \n package com.linkedin.kafka.cruisecontrol.executor.strategy;\n \n+import com.linkedin.kafka.cruisecontrol.exception.PartitionNotExistsException;\n import com.linkedin.kafka.cruisecontrol.executor.ExecutionTask;\n import java.util.Comparator;\n import org.apache.kafka.common.Cluster;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import static com.linkedin.kafka.cruisecontrol.KafkaCruiseControlUtils.isPartitionUnderReplicated;\n \n@@ -15,13 +18,44 @@\n  */\n public class PostponeUrpReplicaMovementStrategy extends AbstractReplicaMovementStrategy {\n \n+  private static final Logger LOG = LoggerFactory.getLogger(PostponeUrpReplicaMovementStrategy.class);\n+\n   @Override\n   public Comparator<ExecutionTask> taskComparator(StrategyOptions strategyOptions) {\n-    return (task1, task2) -> isPartitionUnderReplicated(strategyOptions.cluster(), task1.proposal().topicPartition())\n-                             ? (isPartitionUnderReplicated(strategyOptions.cluster(), task2.proposal().topicPartition()) ? PRIORITIZE_NONE\n-                                                                                                                         : PRIORITIZE_TASK_2)\n-                             : (isPartitionUnderReplicated(strategyOptions.cluster(), task2.proposal().topicPartition()) ? PRIORITIZE_TASK_1\n-                                                                                                                         : PRIORITIZE_NONE);\n+    return (task1, task2) -> {\n+      boolean isTask1PartitionUnderReplicated = false;\n+      boolean isTask2PartitionUnderReplicated = false;\n+      boolean task1PartitionExists = false;\n+      boolean task2PartitionExists = false;\n+      try {\n+        isTask1PartitionUnderReplicated = isPartitionUnderReplicated(strategyOptions.cluster(),\n+            task1.proposal().topicPartition());\n+        task1PartitionExists = true;\n+      } catch (PartitionNotExistsException e) {\n+        LOG.warn(\"Task {} skipped comparison since partition {} does not exist in cluster.\",\n+            task1, task1.proposal().topicPartition());\n+      }\n+      try {\n+        isTask2PartitionUnderReplicated = isPartitionUnderReplicated(strategyOptions.cluster(),\n+            task2.proposal().topicPartition());\n+        task2PartitionExists = true;\n+      } catch (PartitionNotExistsException e) {\n+        LOG.warn(\"Task {} skipped comparison since partition {} does not exist in cluster.\",\n+            task2, task2.proposal().topicPartition());\n+      }\n+\n+      if (task1PartitionExists && task2PartitionExists) {\n+        return isTask1PartitionUnderReplicated\n+            ? (isTask2PartitionUnderReplicated ? PRIORITIZE_NONE : PRIORITIZE_TASK_2)\n+            : (isTask2PartitionUnderReplicated ? PRIORITIZE_TASK_1 : PRIORITIZE_NONE);\n+      } else if (task1PartitionExists) {\n+        return isTask1PartitionUnderReplicated ? PRIORITIZE_NONE : PRIORITIZE_TASK_1;\n+      } else if (task2PartitionExists) {\n+        return isTask2PartitionUnderReplicated ? PRIORITIZE_NONE : PRIORITIZE_TASK_2;\n+      } else {\n+        return PRIORITIZE_NONE;\n+      }\n+    };\n   }\n \n   @Override"
        },
        {
            "sha": "71c6523fcc38d0601d132fa602d4e3cff0514c1d",
            "filename": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/analyzer/PreferredLeaderElectionGoalTest.java",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/linkedin/cruise-control/blob/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fanalyzer%2FPreferredLeaderElectionGoalTest.java",
            "raw_url": "https://github.com/linkedin/cruise-control/raw/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fanalyzer%2FPreferredLeaderElectionGoalTest.java",
            "contents_url": "https://api.github.com/repos/linkedin/cruise-control/contents/cruise-control%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fanalyzer%2FPreferredLeaderElectionGoalTest.java?ref=d7366993b8d560d3761815628d1d3e04f4d4deb8",
            "patch": "@@ -38,6 +38,7 @@\n import static com.linkedin.kafka.cruisecontrol.common.TestConstants.TOPIC0;\n import static com.linkedin.kafka.cruisecontrol.common.TestConstants.TOPIC1;\n import static com.linkedin.kafka.cruisecontrol.common.TestConstants.TOPIC2;\n+import static com.linkedin.kafka.cruisecontrol.common.TestConstants.TOPIC3;\n \n \n public class PreferredLeaderElectionGoalTest {\n@@ -53,6 +54,10 @@ public class PreferredLeaderElectionGoalTest {\n   private static final TopicPartition T2P1 = new TopicPartition(TOPIC2, 1);\n   private static final TopicPartition T2P2 = new TopicPartition(TOPIC2, 2);\n \n+  private static final TopicPartition T3P0 = new TopicPartition(TOPIC3, 0);\n+  private static final TopicPartition T3P1 = new TopicPartition(TOPIC3, 1);\n+  private static final TopicPartition T3P2 = new TopicPartition(TOPIC3, 2);\n+\n   private static final int NUM_RACKS = 4;\n \n   @Test\n@@ -372,6 +377,20 @@ private ClusterModelAndInfo createClusterModel(boolean skipClusterInfoGeneration\n     createReplicaAndSetLoad(clusterModel, \"r2\", 3, logdir(populateDiskInfo, 2, 3), T2P1, 2, true);\n     createReplicaAndSetLoad(clusterModel, \"r3\", 4, logdir(populateDiskInfo, 2, 4), T2P2, 2, true);\n \n+    // The following topic exists in cluster model and not in the cluster\n+    // This is to simulate a case where a topic is deleted from the cluster during an ongoing PLE\n+    createReplicaAndSetLoad(clusterModel, \"r2\", 3, logdir(populateDiskInfo, 0, 4), T3P0, 0, true);\n+    createReplicaAndSetLoad(clusterModel, \"r3\", 4, logdir(populateDiskInfo, 0, 3), T3P1, 0, true);\n+    createReplicaAndSetLoad(clusterModel, \"r3\", 4, logdir(populateDiskInfo, 0, 4), T3P2, 0, true);\n+\n+    createReplicaAndSetLoad(clusterModel, \"r0\", 0, logdir(populateDiskInfo, 1, 4), T3P0, 1, false);\n+    createReplicaAndSetLoad(clusterModel, \"r1\", 2, logdir(populateDiskInfo, 1, 3), T3P1, 1, false);\n+    createReplicaAndSetLoad(clusterModel, \"r2\", 3, logdir(populateDiskInfo, 1, 4), T3P2, 1, false);\n+\n+    createReplicaAndSetLoad(clusterModel, \"r3\", 4, logdir(populateDiskInfo, 2, 4), T3P0, 2, false);\n+    createReplicaAndSetLoad(clusterModel, \"r2\", 3, logdir(populateDiskInfo, 2, 3), T3P1, 2, false);\n+    createReplicaAndSetLoad(clusterModel, \"r1\", 2, logdir(populateDiskInfo, 2, 4), T3P2, 2, false);\n+\n     Cluster cluster = null;\n     if (!skipClusterInfoGeneration) {\n       Node [] nodes = new Node [NUM_RACKS + 1];"
        },
        {
            "sha": "f456d06a9e1c1387bab745cc7b83f136d158660f",
            "filename": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/executor/strategy/PostponeUrpReplicaMovementStrategyTest.java",
            "status": "added",
            "additions": 220,
            "deletions": 0,
            "changes": 220,
            "blob_url": "https://github.com/linkedin/cruise-control/blob/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fexecutor%2Fstrategy%2FPostponeUrpReplicaMovementStrategyTest.java",
            "raw_url": "https://github.com/linkedin/cruise-control/raw/d7366993b8d560d3761815628d1d3e04f4d4deb8/cruise-control%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fexecutor%2Fstrategy%2FPostponeUrpReplicaMovementStrategyTest.java",
            "contents_url": "https://api.github.com/repos/linkedin/cruise-control/contents/cruise-control%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinkedin%2Fkafka%2Fcruisecontrol%2Fexecutor%2Fstrategy%2FPostponeUrpReplicaMovementStrategyTest.java?ref=d7366993b8d560d3761815628d1d3e04f4d4deb8",
            "patch": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.executor.strategy;\n+\n+import com.linkedin.kafka.cruisecontrol.executor.ExecutionProposal;\n+import com.linkedin.kafka.cruisecontrol.executor.ExecutionTask;\n+import com.linkedin.kafka.cruisecontrol.model.ReplicaPlacementInfo;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.PartitionInfo;\n+import org.apache.kafka.common.TopicPartition;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.common.TestConstants.TOPIC0;\n+import static com.linkedin.kafka.cruisecontrol.common.TestConstants.TOPIC1;\n+import static com.linkedin.kafka.cruisecontrol.common.TestConstants.TOPIC2;\n+\n+/*\n+  * Unit test for testing the strategy of postponing the movement of URP replicas.\n+ */\n+public class PostponeUrpReplicaMovementStrategyTest {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(PostponeUrpReplicaMovementStrategyTest.class);\n+\n+  private static final TopicPartition INSYNCP0 = new TopicPartition(TOPIC0, 0);\n+  private static final TopicPartition INSYNCP1 = new TopicPartition(TOPIC0, 1);\n+\n+  private static final TopicPartition URP0 = new TopicPartition(TOPIC1, 0);\n+  private static final TopicPartition URP1 = new TopicPartition(TOPIC1, 1);\n+\n+  private static final TopicPartition DELETEDP0 = new TopicPartition(TOPIC2, 0);\n+  private static final TopicPartition DELETEDP1 = new TopicPartition(TOPIC2, 1);\n+\n+  private static final int NUM_RACKS = 4;\n+\n+  private static final int BROKER_ID_PLACEHOLDER = 0;\n+\n+  static final long PRODUCE_SIZE_IN_BYTES = 10000L;\n+\n+  static final long EXECUTION_ID_PLACEHOLDER = 0;\n+\n+  static final long EXECUTION_ALERTING_THRESHOLD_MS = 100L;\n+\n+  private Cluster _cluster;\n+\n+  /**\n+   * Setup cluster for the test.\n+   */\n+  @Before\n+  public void setUp() {\n+    /*\n+     * Create a cluster with the following strategy:\n+     * 1. TOPIC0 has 2 partitions with 3 replicas each. Both the partitions have all replicas in sync\n+     * 2. TOPIC1 Topic has 2 partitions with 3 replicas each. Both the partitions are URPs.\n+     * 3. TOPIC2 has 2 partitions with 3 replicas each. This topic is deleted from the cluster.\n+     */\n+    Set<PartitionInfo> partitions = new HashSet<>();\n+    Node[] nodes = new Node [NUM_RACKS + 1];\n+    for (int i = 0; i < NUM_RACKS + 1; i++) {\n+      nodes[i] = new Node(i, \"h\" + i, 100);\n+    }\n+\n+    // Add the insync topic partitions to the cluster\n+    partitions.add(new PartitionInfo(INSYNCP0.topic(), INSYNCP0.partition(), nodes[0], new Node[]{nodes[0], nodes[4], nodes[3]},\n+        new Node[]{nodes[0], nodes[4], nodes[3]}));\n+    partitions.add(new PartitionInfo(INSYNCP1.topic(), INSYNCP1.partition(), nodes[1], new Node[]{nodes[1], nodes[2], nodes[4]},\n+        new Node[]{nodes[1], nodes[2], nodes[4]}));\n+\n+    // Add under replicated topic partitions to the cluster\n+    partitions.add(new PartitionInfo(URP0.topic(), URP0.partition(), nodes[1], new Node[]{nodes[1], nodes[3], nodes[2]},\n+        new Node[]{nodes[1], nodes[3]}));\n+    partitions.add(new PartitionInfo(URP1.topic(), URP1.partition(), nodes[3], new Node[]{nodes[3], nodes[4], nodes[0]},\n+        new Node[]{nodes[3], nodes[4]}));\n+\n+    // Build the cluster object to be used by the test cases\n+    _cluster = new Cluster(null, Arrays.asList(nodes),\n+        partitions,\n+        Collections.emptySet(),\n+        Collections.emptySet());\n+  }\n+\n+  /*\n+  * Testcase class for testing the task comparator.\n+  * Contains the following fields:\n+  * 1. Description of the test case\n+  * 2. The first task to be compared\n+  * 3. The second task to be compared\n+  * 4. The expected result of the task priority comparison\n+  */\n+  private static class TaskComparatorTestCase {\n+    private final String _description;\n+    private final ExecutionTask _task0;\n+    private final ExecutionTask _task1;\n+    private final int _expectedResult;\n+\n+    TaskComparatorTestCase(String description, ExecutionTask task0, ExecutionTask task1, int expectedResult) {\n+      _description = description;\n+      _task0 = task0;\n+      _task1 = task1;\n+      _expectedResult = expectedResult;\n+    }\n+\n+    public String description() {\n+      return _description;\n+    }\n+\n+    public ExecutionTask task0() {\n+      return _task0;\n+    }\n+\n+    public ExecutionTask task1() {\n+      return _task1;\n+    }\n+\n+    public int expectedResult() {\n+      return _expectedResult;\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testPostponseUrpReplicaMovementStrategy() {\n+\n+    ReplicaPlacementInfo replicaPlacementInfoPlaceHolder = new ReplicaPlacementInfo(BROKER_ID_PLACEHOLDER);\n+\n+    // Create proposals for each of the above partitions to be used for different test cases\n+    ExecutionProposal inSyncPartitionProposal0 =\n+        new ExecutionProposal(INSYNCP0, PRODUCE_SIZE_IN_BYTES, replicaPlacementInfoPlaceHolder,\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder),\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder));\n+    ExecutionProposal inSyncPartitionProposal1 =\n+        new ExecutionProposal(INSYNCP1, PRODUCE_SIZE_IN_BYTES, replicaPlacementInfoPlaceHolder,\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder),\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder));\n+    ExecutionProposal urpProposal0 =\n+        new ExecutionProposal(URP0, PRODUCE_SIZE_IN_BYTES, replicaPlacementInfoPlaceHolder,\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder),\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder));\n+    ExecutionProposal urpProposal1 =\n+        new ExecutionProposal(URP1, PRODUCE_SIZE_IN_BYTES, replicaPlacementInfoPlaceHolder,\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder),\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder));\n+    ExecutionProposal deletedPartitionProposal0 =\n+        new ExecutionProposal(DELETEDP0, PRODUCE_SIZE_IN_BYTES, replicaPlacementInfoPlaceHolder,\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder),\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder));\n+    ExecutionProposal deletedPartitionProposal1 =\n+        new ExecutionProposal(DELETEDP1, PRODUCE_SIZE_IN_BYTES, replicaPlacementInfoPlaceHolder,\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder),\n+            Collections.singletonList(replicaPlacementInfoPlaceHolder));\n+\n+    // Create execution tasks for each of the above proposals to be used for different test cases\n+    ExecutionTask inSyncPartitionTask0 = new ExecutionTask(EXECUTION_ID_PLACEHOLDER, inSyncPartitionProposal0,\n+        ExecutionTask.TaskType.INTER_BROKER_REPLICA_ACTION, EXECUTION_ALERTING_THRESHOLD_MS);\n+    ExecutionTask inSyncPartitionTask1 = new ExecutionTask(EXECUTION_ID_PLACEHOLDER, inSyncPartitionProposal1,\n+        ExecutionTask.TaskType.INTER_BROKER_REPLICA_ACTION, EXECUTION_ALERTING_THRESHOLD_MS);\n+    ExecutionTask urpTask0 = new ExecutionTask(EXECUTION_ID_PLACEHOLDER, urpProposal0,\n+        ExecutionTask.TaskType.INTER_BROKER_REPLICA_ACTION, EXECUTION_ALERTING_THRESHOLD_MS);\n+    ExecutionTask urpTask1 = new ExecutionTask(EXECUTION_ID_PLACEHOLDER, urpProposal1,\n+        ExecutionTask.TaskType.INTER_BROKER_REPLICA_ACTION, EXECUTION_ALERTING_THRESHOLD_MS);\n+    ExecutionTask deletedPartitionTask0 = new ExecutionTask(EXECUTION_ID_PLACEHOLDER, deletedPartitionProposal0,\n+        ExecutionTask.TaskType.INTER_BROKER_REPLICA_ACTION, EXECUTION_ALERTING_THRESHOLD_MS);\n+    ExecutionTask deletedPartitionTask1 = new ExecutionTask(EXECUTION_ID_PLACEHOLDER, deletedPartitionProposal1,\n+        ExecutionTask.TaskType.INTER_BROKER_REPLICA_ACTION, EXECUTION_ALERTING_THRESHOLD_MS);\n+\n+    Comparator<ExecutionTask> taskComparator = new PostponeUrpReplicaMovementStrategy().taskComparator(_cluster);\n+\n+    int prioritizeNone = PostponeUrpReplicaMovementStrategy.PRIORITIZE_NONE;\n+    int prioritizeTask1 = PostponeUrpReplicaMovementStrategy.PRIORITIZE_TASK_1;\n+    int prioritizeTask2 = PostponeUrpReplicaMovementStrategy.PRIORITIZE_TASK_2;\n+\n+    // Test cases\n+    List<TaskComparatorTestCase> tcList = new ArrayList<>();\n+\n+    // Test 1: both tasks are in-sync replicas - prioritize none.\n+    tcList.add(new TaskComparatorTestCase(\"Both tasks are for in-sync replica movements\", inSyncPartitionTask0,\n+        inSyncPartitionTask1, prioritizeNone));\n+\n+    // Test 2: insync task and urp task - prioritize insync task.\n+    tcList.add(new TaskComparatorTestCase(\"Task1-insync Task2-urp\", inSyncPartitionTask1, urpTask1, prioritizeTask1));\n+    tcList.add(new TaskComparatorTestCase(\"Task1-urp Task2-insync\", urpTask1, inSyncPartitionTask1, prioritizeTask2));\n+\n+    // Test 3: insync task and deleted partition task - prioritize insync task.\n+    tcList.add(new TaskComparatorTestCase(\"Task1-insync Task2-deleted partition\", inSyncPartitionTask1,\n+        deletedPartitionTask0, prioritizeTask1));\n+    tcList.add(new TaskComparatorTestCase(\"Task1-deleted partition Task2-insync\", deletedPartitionTask0,\n+        inSyncPartitionTask1, prioritizeTask2));\n+\n+    // Test 4: Both urp tasks - prioritize none\n+    tcList.add(new TaskComparatorTestCase(\"Both tasks are urps.\", urpTask0, urpTask1, prioritizeNone));\n+\n+    // Test 5: urp task and deleted partition task - prioritize None\n+    tcList.add(new TaskComparatorTestCase(\"Task1-URP Task2-Deleted Partition\", urpTask1, deletedPartitionTask1, prioritizeNone));\n+    tcList.add(new TaskComparatorTestCase(\"Task1-Deleted Partition Task2-URP \", deletedPartitionTask1, urpTask1, prioritizeNone));\n+\n+    // Test 6: Both deleted partition tasks - prioritize none\n+    tcList.add(new TaskComparatorTestCase(\"Both tasks are for deleted topics\", deletedPartitionTask1, deletedPartitionTask0, prioritizeNone));\n+\n+    // Iterate over all the test cases and run the comparator\n+    // Assert with the expected result\n+    for (TaskComparatorTestCase tc : tcList) {\n+      LOG.info(\"Test case: {}\", tc.description());\n+      int result = taskComparator.compare(tc.task0(), tc.task1());\n+      Assert.assertEquals(tc.description(), tc.expectedResult(), result);\n+    }\n+  }\n+}"
        }
    ]
}